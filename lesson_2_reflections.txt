1) What happens when you initialize a repository? Why do you need to do it?
	-Initialiazing a repository creates a .git file in the directory where it is initialized. This allows you to begin tracking files in that directory from that point forward. You must manually add files to be tracked by the repository.

2) How is the staging area different from the working directory and the repository? What value do you think it offers?
	-The staging area is a temporary holding place for files that will be added to the repository in the next commit. Their state is in flux. Files in the working directory have one save state, but may have as many versions as there are commits for them in the repository. The staging area allows you to select which files will be added in a commit, so that you can commit logical groups of files rather than commiting all the files in the directory at once.
3) How can you use the staging area to make sure you have one commit per logical change? 
	-You can compare the files in the staging area to those in either the working directory or repository to view the differences between them, to ensure that the right amount of code is being added in the next commit.
4) What are some situations when branches would be helpful in keeping your history organized? How would branches help?
	If you need to make different versions of a file (different languages, adding new features to only one version, making a more complex edition) branches allow you to maintain a basic version of the code as well as separate specialized versions. This allows you to track only the changes that are relevant to that specific branch without cluttering the logs with all the changes that are also being made to the master code simulatneously.
5) How do the diagrams help you visualize the branch structure? 
	-They make it easier to view the parent of any commit, and make it easier to view where a bracnch fits in relation to the master branch. It is also easier to tell which commits are reachable from each branch and which are unreachable.
6) What is the result of merging two branches together? Why do we represent it in the diagram the way we do?
	-Merging two branches together merges code added or deleted in a branch with that of another existing branch. Pieces of code are included or not in a merge based on when they occered in the timeline, whether they exist in both branches, etc. Sometimes you will have to manually specify which changes to keep. It is represented in the diagram the way it is to denote that each branch has its own timeline/parent commits, and also to illustrate which branches are reachable from which others.